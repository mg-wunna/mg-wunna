import { ArticleLayout } from '@/components/article-layout.component'
import idealArchitecture from './images/ideal_architecture_principles_diagram.png'
import componentsOveruse from './images/components_overuse_example.png'
import scatteredRedux from './images/scattered_redux_logic_example.png'
import modularLayers from './images/modular_architecture_layers.png'
import moduleApi from './images/module_and_public_api_structure.png'
import fsdLayers from './images/fsd_layer_structure.png'

export const article = {
  author: 'Mg Wunna',
  date: '2024-08-16',
  title: 'Architectures of Modern Front-End Applications',
  description:
    "Modern frontend applications need to be flexible, scalable, and maintainable. Let's explore different architectural approaches that can help achieve these goals.",
}

export const metadata = {
  title: article.title,
  description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

<div style={{ width: '100%' }}>
  <Image
    src="https://placehold.co/1200x600/ef4444/ffffff.png?font=lato&text=Modern+Frontend+Architectures"
    alt="Cover"
    width={1200}
    height={600}
    style={{ width: '100%', height: 'auto' }}
  />
</div>

Modern frontend applications need to be flexible, scalable, and maintainable. Let's explore different architectural approaches that can help achieve these goals.

## What's Beyond Just "Folder Structure"?

Many developers think architecture is just about organizing folders, but it's much more than that. Good architecture includes:

- **Module Communication**: How different parts of your app work together
- **Easy Navigation**: Clear organization that makes sense
- **Separated Logic**: Keeping business logic away from UI components
- **DRY Principle**: Don't Repeat Yourself
- **Divide and Conquer**: Breaking big problems into smaller ones

<Image src={idealArchitecture} alt="Ideal architecture principles diagram" />

## Classic Architecture (No Architecture)

This is what many developers start with - simple folders like "pages", "components", and "helpers". While it works for small projects, it can become messy as your app grows.

<Image src={componentsOveruse} alt="Components overuse example" />

### Problems with Classic Architecture:

- Components become too dependent on each other
- Business logic gets scattered across different files
- Hard to maintain as the project grows

<Image src={scatteredRedux} alt="Scattered Redux logic example" />

This approach might work well for:

- Tiny teams (1-2 developers)
- MVP projects
- Short-term projects
- Learning projects

## Modular Architecture

Modular architecture organizes code into distinct layers:

- Pages
- Modules
- Components
- UI

<Image src={modularLayers} alt="Modular architecture layers" />

Each layer can only use components from layers below it. For example:

- Pages can use modules
- Modules can use components
- Components can use UI elements
- UI is the foundation layer

<Image src={moduleApi} alt="Module and public API structure" />

Important rules:

- Modules shouldn't use other modules
- Components should keep logic simple
- Each module needs a clear public API

## Feature Sliced Design (FSD)

FSD takes modular architecture to the next level by organizing code by features instead of just layers.

Layers in FSD (from top to bottom):

1. Pages
2. Features/Widgets
3. Entities
4. Shared

<Image src={fsdLayers} alt="FSD layer structure" />

Benefits of FSD:

- Clear structure
- Strong layer boundaries
- Flexible components
- Independent modules
- Better reusability

Pro tip: FSD recommends using kebab-case for file names:
